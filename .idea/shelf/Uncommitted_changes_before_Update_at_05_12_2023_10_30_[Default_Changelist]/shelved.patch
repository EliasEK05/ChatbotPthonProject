Index: function.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nfrom random import *\r\nfrom math import *\r\n#fonction permetant de faire une liste des nom nom des fichier dans le dossier speeches ( fonction donné dans l'éononcé du projet\r\ndef list_of_files(directory, extension):\r\n    files_names = []\r\n    for filename in os.listdir(directory):\r\n        if filename.endswith(extension):\r\n            files_names.append(filename)\r\n    return files_names\r\n\r\n\r\n\r\n#Fonction pour extraire les noms des présidents à partir des noms des fichiers texte fournis\r\ndef extraction_nom():\r\n    list_nom_fichier = list_of_files(\"speeches\", \"txt\")\r\n    list_nom_president = []\r\n    for nom in list_nom_fichier:\r\n        nom = nom[11:-4]\r\n        if nom[-1] in \"123456789\":\r\n            nom = nom[:-1]\r\n        list_nom_president.append(nom)\r\n    return list_nom_president\r\n\r\n\r\n\r\n#Associer à chaque président un prénom (add dans le dico info president)\r\ndef prenom_president():\r\n    list_nom_president = extraction_nom()\r\n    dico_noms = {}\r\n    for nom in list_nom_president:\r\n        if nom == \"Chirac\":\r\n            dico_noms[nom] = \"Jacques\"\r\n        elif nom == \"Giscard dEstaing\":\r\n            dico_noms[nom] = \"Valery\"\r\n        elif nom == \"Hollande\" or nom == \"Mitterrand\":\r\n            dico_noms[nom] = \"François\"\r\n        elif nom == \"Sarkozy\":\r\n            dico_noms[nom] = \"Nicolas\"\r\n    return dico_noms\r\n\r\n\r\n\r\n# Afficher la liste des noms des présidents (attention aux doublons)\r\ndef list_president():\r\n    list_nom_president = extraction_nom()\r\n    list_nom_president_clean = []\r\n    for nom in list_nom_president:\r\n        if nom not in list_nom_president_clean:\r\n            list_nom_president_clean.append(nom)\r\n    return list_nom_president_clean\r\n\r\n\r\n\r\n\r\n\r\n\r\n'''Convertir  les textes des 8 fichiers en minuscules et stocker les contenus dans de nouveaux fichiers. Les\r\nnouveaux fichiers doivent être stockés dans un nouveau dossier appelé « cleaned ». Ce dossier doit se\r\nsituer dans le répertoire principal où se trouve le programme main.py et au même niveau que le répertoire\r\n« speeches »'''\r\n\r\ndef nettoyage_fichier():\r\n    list_nom_fichier_speeches = list_of_files(\"speeches\", \"txt\")\r\n    chemin_dossier_cleaned = r\"C:\\Users\\elias\\PycharmProjects\\pythonProject\\cleaned\"      #le r permet à ce que la chaine de caractère soit interpreter correctement et qu'il n'y ai pas d'erreur d'interprétation\r\n    chemin_dossier_speeches = r\"C:\\Users\\elias\\PycharmProjects\\pythonProject\\speeches\"\r\n    for i in list_nom_fichier_speeches:\r\n        nom_fichier_clean = i[:-4] + \"_clean\" + \".txt\"\r\n        chemin_fichier = os.path.join(chemin_dossier_cleaned, nom_fichier_clean)\r\n        nom_fichier_discours = os.path.join(chemin_dossier_speeches, i)\r\n        with open(nom_fichier_discours, \"r\", encoding='utf-8') as a, open(chemin_fichier, \"w\",encoding='utf-8') as b:\r\n            texte = a.read()\r\n            for car in texte:\r\n                b.write(minuscule(car))\r\n\r\n\r\n#Fonction permettant de mettre une lettre en minuscule, utilisé pour la fonction nettoyage_fichier\r\ndef minuscule(lettre):\r\n    if ord(lettre) >= 65 and ord(lettre) <= 90:\r\n        lettre = chr(ord(lettre) + 32)\r\n    return lettre\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n'''Pour chaque fichier stocké dans le répertoire « cleaned », parcourir son texte et supprimer tout caractère\r\nde ponctuation. Le résultat final doit donner un fichier avec des mots séparés par des espaces. Attention,\r\ncertains caractères comme l’apostrophe (‘) ou le tiret (-) nécessitent un traitement spécial pour ne pas\r\ncauser une concaténation de deux mots (exemple : « elle-même » devrait devenir « elle même » et non\r\npas « ellemême »). Les modifications réalisées à cette étape devraient être stockées dans les mêmes\r\nfichiers du répertoire « cleaned ».'''\r\n\r\n\r\ndef suppresion_ponctuation():\r\n    liste_nom_fichier_cleaned = list_of_files(\"cleaned\", \"txt\")\r\n    chemin_dossier_cleaned = r\"C:\\Users\\elias\\PycharmProjects\\pythonProject\\cleaned\"\r\n    i = 0\r\n    for i in liste_nom_fichier_cleaned:\r\n        chemin_fichier = os.path.join(chemin_dossier_cleaned, i)\r\n        with open(chemin_fichier, 'r', encoding='utf-8') as F1:\r\n            texte = F1.read()\r\n\r\n        with open(chemin_fichier, 'w', encoding='utf-8') as F2:\r\n            for car in texte:\r\n                if car in ['.', ',', '\"', '!', '?', ';', ':']:\r\n                    car = ''\r\n                elif car in [\"-\", \"'\"]:\r\n                    car = ' '\r\n                F2.write(car)\r\n\r\n#fonction permettant de return la liste des texte des fichiers cleaned\r\ndef liste_texte():\r\n    liste = list_of_files(\"cleaned\", \"txt\")\r\n    liste_texte = []\r\n    for fichier in liste:\r\n        with open(\"cleaned//\" + fichier, 'r', encoding = 'utf-8') as F:\r\n            texte = F.read()\r\n            liste_texte.append(texte)\r\n    return liste_texte\r\n\r\n#foncion permettant de return la liste des fichiers cleaned en combinant les deux discours de Chirac et les deux discours de Miterrand\r\ndef liste_texte_president():\r\n    liste = liste_texte()\r\n    txt_chirac = liste[0] + liste[1]\r\n    txt_mitterand = liste[5] + liste[6]\r\n    liste[0] = txt_chirac\r\n    liste.pop(1)\r\n    liste[4] = txt_mitterand\r\n    liste.pop(5)\r\n    return liste\r\n\r\n\r\n# Écrire une fonction qui prend en paramètre une chaine de caractères et qui retourne un dictionnaire\r\n#associant à chaque mot le nombre de fois qu’il apparait dans la chaine de caractères.\r\n\r\ndef TF(chaine):\r\n    dico = {}\r\n    mots = chaine.split()\r\n    for mot in mots:\r\n        if mot in dico:\r\n            dico[mot] +=1\r\n        else:\r\n            dico[mot] = 1\r\n    return dico\r\n\r\n\r\n\r\n#Écrire une fonction qui prend en paramètre le répertoire où se trouve l’ensemble des fichiers du corpus\r\n#et qui retourne un dictionnaire associant à chaque mot son score IDF.\r\n\r\ndef IDF(directory):\r\n    liste_mots_par_fichier = []\r\n    dico_score_idf = {}\r\n    nb_documents_total = 0\r\n    for fichier in os.listdir(directory):\r\n        nb_documents_total += 1\r\n        liste_mot = []\r\n        with open(\"cleaned//\" + fichier, 'r', encoding='utf-8') as F:\r\n            for ligne in F:\r\n                mots = ligne.split()\r\n                for mot in mots:\r\n                    if mot not in liste_mot:\r\n                        liste_mot.append(mot)\r\n        liste_mots_par_fichier.append(liste_mot)\r\n        F.close()\r\n    for liste in liste_mots_par_fichier:\r\n        for mot in liste:\r\n            if mot in dico_score_idf:\r\n                dico_score_idf[mot] += 1\r\n            else:\r\n                dico_score_idf[mot] = 1\r\n    for mot in dico_score_idf:\r\n            dico_score_idf[mot] = log(nb_documents_total / dico_score_idf[mot])\r\n    return dico_score_idf\r\n\r\n\r\n#Écrire une fonction qui prend en paramètre le répertoire où se trouvent les fichiers à analyser et qui\r\n#retourne au minimum la matrice TF-IDF.\r\n'''def matrice_TF_IDF(directory):\r\n    liste_dico_tf = []\r\n    liste_mot_idf = []\r\n    score_IDF = IDF(directory)\r\n    for i in score_IDF.keys():\r\n        liste_mot_idf.append(i)\r\n    liste_mot_idf.append(\" \")\r\n    \r\n    for fichier in os.listdir(directory):\r\n        with open(\"cleaned//\" + fichier, 'r', encoding='utf-8') as F:\r\n            texte = F.read()\r\n            dico_tf_par_texte = TF(texte)\r\n            dico_tf_par_texte['nom'] = fichier                               \r\n            liste_dico_tf.append(dico_tf_par_texte)\r\n        liste_dico_tf.append(\" \")\r\n\r\n    nblig = len(score_IDF)+1\r\n    nbcol = len(liste_dico_tf)+1\r\n    matrice = []\r\n\r\n    for i in range(nblig+1):\r\n        ligne = []\r\n        for j in range(nbcol+1):\r\n            ligne.append(\" \")\r\n        matrice.append(ligne)\r\n\r\n    for j in range(1,len(matrice)):\r\n        matrice[0][j] = liste_dico_tf[j-1][\"nom\"]\r\n\r\n    for i in range(1,len(matrice[0])):\r\n        matrice[i][0] = liste_mot_idf[i-1]\r\n    return matrice\r\n'''\r\n\r\n\r\ndef tfidf(directory=\"./cleaned\"):\r\n    liste_des_mots = IDF(directory)\r\n    matrice_tf_idf = []\r\n    id = 0\r\n    for mot in liste_des_mots:\r\n        matrice_tf_idf.append([])\r\n        for file in list_of_files(directory, \".txt\"):\r\n            with open(directory + \"/\" + file, \"r\") as f:\r\n                dico_mot_fichier = TF(f.read())\r\n            if mot in dico_mot_fichier:\r\n                matrice_tf_idf[id].append(dico_mot_fichier[mot] * liste_des_mots[mot])\r\n            else:\r\n                matrice_tf_idf[id].append(0.0)\r\n        id += 1\r\n    return matrice_tf_idf\r\n\r\n\r\n\r\n\r\n#Fonctionnalités à développer\r\n\r\n#Fonctionnalité 1 : Afficher la liste des mots les moins importants dans le corpus de documents. Un mot est dit non important, si son TD-IDF = 0 dans tous les fichiers.\r\n\r\ndef fonctionnalite_1():\r\n    matrice_TF_IDF = tfidf(\"cleaned\")\r\n    liste_mot_pas_important = []\r\n    i = 0\r\n    liste_mot = list(IDF(\"cleaned\").keys())\r\n    for ligne in matrice_TF_IDF:\r\n        verif = True\r\n        for colonne in ligne:\r\n            if colonne != 0:\r\n                verif = False\r\n        if verif == True:\r\n            liste_mot_pas_important.append(liste_mot[i])\r\n        i += 1\r\n    return liste_mot_pas_important\r\n\r\n    return liste_mot_pas_important\r\n\r\n\r\n#Fonctionnalité 2 : Afficher le(s) mot(s) ayant le score TD-IDF le plus élevé\r\n'''\r\ndef fonctionnalite_2():\r\n \r\n    return liste_mot_important\r\n'''\r\n\r\n\r\n\r\n#fonctionnalité 3: Indiquer le(s) mot(s) le(s) plus répété(s) par le président Chirac\r\n\r\ndef fonctionnalite_3():\r\n    liste_texte = liste_texte_president()\r\n    txt_chirac = liste_texte[0]\r\n    tf_chirac = TF(txt_chirac)\r\n    max = 0\r\n    for mot in tf_chirac:\r\n        if tf_chirac[mot] > max:\r\n            max = tf_chirac[mot]\r\n    mot_plus_repetes = []\r\n    for mot in tf_chirac:\r\n        if tf_chirac[mot] == max:\r\n            mot_plus_repetes.append(mot)\r\n    return mot_plus_repetes, max\r\n\r\n#fonctionnalité 4: Indiquer le(s) nom(s) du (des) président(s) qui a (ont) parlé de la « Nation » et celui qui l’a répété le plus de fois\r\n\r\ndef fonctionnalite_4():\r\n\r\n    liste_texte = liste_texte_president()\r\n    liste_repetition_nation = []\r\n    president_nation = []\r\n    nom_president = list_president()\r\n    i = 0\r\n    for texte in liste_texte:\r\n        tf_texte = TF(texte)\r\n        for mot in tf_texte:\r\n            if mot == \"nation\":\r\n                president_nation.append(nom_president[i])\r\n                liste_repetition_nation.append(tf_texte[mot])\r\n        i += 1\r\n    repetition_max = 0\r\n    indice = 0\r\n    for nb in liste_repetition_nation:\r\n        if nb > repetition_max:\r\n            repetition_max = nb\r\n            indice_president = indice\r\n        indice += 1\r\n\r\n    return president_nation, president_nation[indice_president], repetition_max\r\n\r\n\r\n#fonctionnalité 5: Indiquer le premier président à parler du climat et/ou de l’écologie\r\n\r\ndef fonctionnalite_5():\r\n    liste_texte = liste_texte_president()\r\n    nom_president = list_president()\r\n    i = 0\r\n    president_climat = \"\"\r\n    verif = False\r\n    while verif == False and i < len(liste_texte):\r\n        txt = liste_texte[i]\r\n        tf_mot = TF(txt)\r\n        for mot in tf_mot:\r\n            if 'climat' in mot or 'écologie' in mot:\r\n                president_climat = nom_president[i]\r\n                verif = True\r\n        i += 1\r\n    return president_climat\r\n\r\n#fonctionalité 6 : Hormis les mots dits « non importants », quel(s) est(sont) le(s) mot(s) que tous les présidents ont évoqués.\r\n'''\r\ndef fonctionnalité_6():\r\n    liste_texte = liste_texte_president()\r\n    liste_mots = []\r\n    mots_retire = []\r\n    i = 0\r\n    dico_mot ={}\r\n    for txt in liste_texte:\r\n        TF_txt = TF(txt)\r\n        for mot in TF_txt:\r\n            if i == 0:\r\n                dico_mot[mot] = 1\r\n            else:\r\n                if mot in dico_mot:\r\n                    dico_mot[mot] += 1\r\n        i += 1\r\n    for mot in dico_mot:\r\n        if dico_mot[mot] == 6:\r\n            liste_mots.append(mot)\r\n    matrice_TF_IDF = matrice_TF_IDF()\r\n    i = 0\r\n    for mot in liste_mots:\r\n        for ligne in matrice_TF_IDF:\r\n            for colonne in matrice_TF_IDF[ligne]:\r\n\r\n    return liste_mots\r\n\r\n'''\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/function.py b/function.py
--- a/function.py	(revision 4e8285c79acef3d87d148fa6667a612c069cf9bf)
+++ b/function.py	(date 1701165964862)
@@ -252,15 +252,13 @@
         i += 1
     return liste_mot_pas_important
 
-    return liste_mot_pas_important
-
 
 #Fonctionnalité 2 : Afficher le(s) mot(s) ayant le score TD-IDF le plus élevé
-'''
+
 def fonctionnalite_2():
- 
+    liste_mot_important
     return liste_mot_important
-'''
+
 
 
 
